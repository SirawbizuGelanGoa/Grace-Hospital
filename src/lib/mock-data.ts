
// This file simulates a backend using in-memory data,
// with structures aligned to the user's SQL schema for future backend integration.
// Data is persisted to localStorage for prototyping purposes.

// --- SQL Schema Aligned TypeScript Types ---

export type SiteSettingsSQL = {
    id: string; // Usually auto-generated by DB
    hospitalName: string;
    logoUrl?: string | null;
    facebookUrl?: string | null;
    tiktokUrl?: string | null;
    telegramUrl?: string | null;
    created_at?: string; // Usually auto-generated by DB
};

export type HeroSlideSQL = {
    id: string;
    src: string;
    alt: string;
    hint?: string | null;
    title?: string | null;
    subtitle?: string | null;
    ctaLink?: string | null;
    ctaText?: string | null;
    position?: number | null;
    created_at?: string;
};

export type AboutContentSQL = {
    id: string;
    title: string;
    description: string;
    mission: string;
    vision: string;
    imageUrl?: string | null;
    imageHint?: string | null;
    created_at?: string;
};

export type ServiceSQL = {
  id: string;
  name: string;
  description: string; // Short description for the front of the card
  detailedDescription: string; // Longer description for the back of the card
  iconName: string;
  created_at?: string;
};

export type FacilitySQL = {
    id: string;
    name: string;
    description: string;
    iconName: string;
    imageUrl?: string | null;
    imageHint?: string | null;
    detailedDescription: string;
    created_at?: string;
};

export type DepartmentSQL = {
    id: string;
    name: string;
    description: string;
    iconName: string;
    detailedDescription: string;
    headOfDepartmentImage?: string | null;
    headOfDepartmentImageHint?: string | null;
    created_at?: string;
};

export type GalleryItemSQL = {
    id: string;
    type: 'photo' | 'video';
    src: string;
    alt: string;
    hint?: string | null;
    position?: number | null;
    created_at?: string;
};

export type NewsEventSQL = {
    id: string;
    title: string;
    date: string; // ISO string date YYYY-MM-DD for SQL DATE type
    summary: string;
    fullContent: string;
    image: string;
    link: string; // Unique slug, starts with '/'
    hint?: string | null;
    created_at?: string;
};

export type ContactInfoSQL = {
    id: string;
    address: string;
    phone: string;
    email: string;
    mapPlaceholder?: string | null;
    created_at?: string;
};


// --- In-Memory Database Structure (Aligned with SQL Schema) ---
interface MockDb {
    site_settings: SiteSettingsSQL[]; // Should ideally be a single row
    hero_slides: HeroSlideSQL[];
    about_content: AboutContentSQL[]; // Should ideally be a single row
    services: ServiceSQL[];
    facilities: FacilitySQL[];
    departments: DepartmentSQL[];
    gallery_items: GalleryItemSQL[];
    news_events: NewsEventSQL[];
    contact_info: ContactInfoSQL[]; // Should ideally be a single row
}

const initialMockDbData: MockDb = {
    site_settings: [
        {
            id: 'ss_main', // Fixed ID for single row
            hospitalName: 'Grace Hospital',
            logoUrl: '',
            facebookUrl: 'https://facebook.com/gracehospital',
            tiktokUrl: 'https://tiktok.com/@gracehospital',
            telegramUrl: 'https://t.me/gracehospital',
            created_at: new Date().toISOString(),
        }
    ],
    hero_slides: [
        {
            id: 'hs1',
            src: 'https://picsum.photos/1200/800?random=hero1',
            alt: 'State-of-the-art medical facility',
            hint: 'modern hospital',
            title: 'Welcome to Grace Hospital',
            subtitle: 'Your Health, Our Priority. Providing compassionate care.',
            ctaLink: '#contact',
            ctaText: 'Book Appointment',
            position: 1,
            created_at: new Date().toISOString(),
        },
        {
            id: 'hs2',
            src: 'https://picsum.photos/1200/800?random=hero2',
            alt: 'Dedicated medical team',
            hint: 'doctors team',
            title: 'Expert Care, Always',
            subtitle: 'Meet our world-class specialists.',
            ctaLink: '#departments',
            ctaText: 'Our Departments',
            position: 2,
            created_at: new Date().toISOString(),
        },
    ],
    about_content: [
        {
            id: 'ac_main', // Fixed ID for single row
            title: 'About Grace Hospital',
            description: 'Grace Hospital is committed to providing exceptional healthcare services with compassion and expertise. Our state-of-the-art facility is equipped with the latest technology, and our dedicated team of medical professionals works tirelessly to ensure the well-being of our patients. We believe in a patient-centric approach, offering personalized care tailored to individual needs.',
            mission: 'Our mission is to improve the health of our community by delivering high-quality, accessible, and comprehensive healthcare services.',
            vision: 'Our vision is to be the leading healthcare provider in the region, recognized for clinical excellence, patient satisfaction, and innovation.',
            imageUrl: 'https://picsum.photos/600/400?random=aboutGrace',
            imageHint: 'hospital staff',
            created_at: new Date().toISOString(),
        }
    ],
    services: [
        { id: 's1', name: 'General Medicine', description: 'Comprehensive care for adults and children.', detailedDescription: 'Our General Medicine department provides a wide range of services including routine check-ups, preventive care, management of chronic illnesses, and treatment for acute medical conditions. We focus on holistic patient health.', iconName: 'Stethoscope', created_at: new Date().toISOString() },
        { id: 's2', name: 'Cardiology', description: 'Expert heart care and diagnostics.', detailedDescription: 'The Cardiology department specializes in the diagnosis and treatment of heart diseases and cardiovascular conditions. We offer advanced diagnostic tools like ECG, echocardiography, and stress tests, along with personalized treatment plans.', iconName: 'HeartPulse', created_at: new Date().toISOString() },
    ],
    facilities: [
        { id: 'f1', name: 'Modern Patient Rooms', description: 'Comfortable and well-equipped for recovery.', iconName: 'BedDouble', imageUrl: 'https://picsum.photos/600/400?random=facility1', imageHint: 'patient room', detailedDescription: 'Our modern patient rooms are designed for comfort and recovery...', created_at: new Date().toISOString() },
        { id: 'f2', name: 'Advanced Laboratory', description: 'State-of-the-art diagnostic testing.', iconName: 'FlaskConical', imageUrl: 'https://picsum.photos/600/400?random=facility2', imageHint: 'science lab', detailedDescription: 'Equipped with the latest technology, our advanced laboratory provides...', created_at: new Date().toISOString() },
    ],
    departments: [
        {
            id: 'd1',
            name: 'Cardiology',
            description: 'Specializing in heart and vascular system disorders.',
            iconName: 'HeartPulse',
            detailedDescription: 'The Cardiology Department at Grace Hospital offers comprehensive care...',
            headOfDepartmentImage: 'https://picsum.photos/300/300?random=hod1',
            headOfDepartmentImageHint: 'cardiologist portrait',
            created_at: new Date().toISOString(),
        },
    ],
    gallery_items: [
        { id: 'p1', type: 'photo', src: 'https://picsum.photos/400/300?random=gallery1', alt: 'Hospital lobby', hint: 'hospital lobby', position: 1, created_at: new Date().toISOString() },
        { id: 'p2', type: 'photo', src: 'https://picsum.photos/400/300?random=gallery2', alt: 'Modern operating room', hint: 'operating room', position: 2, created_at: new Date().toISOString() },
        { id: 'v1', type: 'video', src: 'https://picsum.photos/400/300?random=video1', alt: 'Hospital Tour Video Placeholder', hint: 'hospital video', position: 3, created_at: new Date().toISOString() },
    ],
    news_events: [
         {
            id: 'n1',
            title: 'Grace Hospital Opens New Cardiology Wing',
            date: '2024-07-15', // YYYY-MM-DD
            summary: 'Our expanded cardiology department offers cutting-edge treatments and diagnostics.',
            fullContent: 'Grace Hospital is thrilled to announce the grand opening of its new, state-of-the-art Cardiology Wing...',
            image: 'https://picsum.photos/400/250?random=news1',
            link: '/news/new-cardiology-wing',
            hint: 'hospital wing',
            created_at: new Date().toISOString(),
        },
    ],
    contact_info: [
        {
            id: 'ci_main', // Fixed ID for single row
            address: '123 Grace Hospital Way, Healthville, ST 54321',
            phone: '(123) 456-7890',
            email: 'info@gracehospital.example',
            mapPlaceholder: '34.052235,-118.243683', // Example coordinates
            created_at: new Date().toISOString(),
        }
    ],
};

let mockDb: MockDb = JSON.parse(JSON.stringify(initialMockDbData));

const persistDb = () => {
  if (typeof window !== 'undefined') {
    try {
      localStorage.setItem('mockDbSQL', JSON.stringify(mockDb));
    } catch (e) {
      console.error("Error saving mockDbSQL to localStorage", e);
    }
  }
};

const loadDb = () => {
  if (typeof window !== 'undefined') {
    const storedDbString = localStorage.getItem('mockDbSQL');
    if (storedDbString) {
      try {
        const storedDbParsed = JSON.parse(storedDbString) as MockDb;
        // Merge with initial data to ensure all keys exist and new items are added if schema changed
        const newDbState: MockDb = JSON.parse(JSON.stringify(initialMockDbData));
        (Object.keys(newDbState) as Array<keyof MockDb>).forEach(key => {
          if (storedDbParsed[key]) {
            if (Array.isArray(newDbState[key])) {
              (newDbState[key] as any[]) = storedDbParsed[key] as any[];
            } else {
              (newDbState[key] as any) = storedDbParsed[key];
            }
          }
        });
        mockDb = newDbState;

      } catch (error) {
        console.error("Error parsing mockDbSQL from localStorage. Resetting to initial state.", error);
        mockDb = JSON.parse(JSON.stringify(initialMockDbData));
        persistDb();
      }
    } else {
      mockDb = JSON.parse(JSON.stringify(initialMockDbData));
      persistDb();
    }
  }
};

if (typeof window !== 'undefined') {
  loadDb();
}

const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));
const SIMULATED_DELAY = 50;
const generateId = () => Date.now().toString(36) + Math.random().toString(36).substring(2, 9);

// --- API Functions (CRUD for each table) ---

// --- Site Settings (Single Row Table) ---
export const getSiteSettings = async (): Promise<SiteSettingsSQL> => {
    await delay(SIMULATED_DELAY);
    loadDb();
    // Assuming site_settings always has one row or defaults to the first.
    return JSON.parse(JSON.stringify(mockDb.site_settings[0] || initialMockDbData.site_settings[0]));
};

export const updateSiteSettings = async (data: Partial<Omit<SiteSettingsSQL, 'id' | 'created_at'>>): Promise<SiteSettingsSQL> => {
    await delay(SIMULATED_DELAY);
    loadDb();
    // Assuming site_settings has a fixed ID like 'ss_main' or always updates the first record.
    const currentSettings = mockDb.site_settings[0] || { ...initialMockDbData.site_settings[0], id: 'ss_main' };
    mockDb.site_settings[0] = { ...currentSettings, ...data, id: currentSettings.id, created_at: currentSettings.created_at || new Date().toISOString() };
    persistDb();
    return JSON.parse(JSON.stringify(mockDb.site_settings[0]));
};


// --- Hero Slides ---
export const getHeroSlides = async (): Promise<HeroSlideSQL[]> => {
    await delay(SIMULATED_DELAY);
    loadDb();
    return JSON.parse(JSON.stringify(mockDb.hero_slides.sort((a, b) => (a.position || 0) - (b.position || 0))));
};

export const createHeroSlide = async (data: Omit<HeroSlideSQL, 'id' | 'created_at'>): Promise<HeroSlideSQL> => {
    await delay(SIMULATED_DELAY);
    loadDb();
    const newSlide: HeroSlideSQL = { ...data, id: generateId(), created_at: new Date().toISOString() };
    mockDb.hero_slides.unshift(newSlide);
    persistDb();
    return JSON.parse(JSON.stringify(newSlide));
};

export const updateHeroSlide = async (id: string, data: Partial<Omit<HeroSlideSQL, 'id' | 'created_at'>>): Promise<HeroSlideSQL | null> => {
    await delay(SIMULATED_DELAY);
    loadDb();
    const index = mockDb.hero_slides.findIndex(s => s.id === id);
    if (index === -1) return null;
    mockDb.hero_slides[index] = { ...mockDb.hero_slides[index], ...data };
    persistDb();
    return JSON.parse(JSON.stringify(mockDb.hero_slides[index]));
};

export const deleteHeroSlide = async (id: string): Promise<boolean> => {
    await delay(SIMULATED_DELAY);
    loadDb();
    const initialLength = mockDb.hero_slides.length;
    mockDb.hero_slides = mockDb.hero_slides.filter(s => s.id !== id);
    const success = mockDb.hero_slides.length < initialLength;
    if (success) persistDb();
    return success;
};


// --- About Content (Single Row Table) ---
export const getAboutContent = async (): Promise<AboutContentSQL> => {
    await delay(SIMULATED_DELAY);
    loadDb();
    return JSON.parse(JSON.stringify(mockDb.about_content[0] || initialMockDbData.about_content[0]));
};

// For single-row tables, update usually means updating the existing row.
export const updateAboutContent = async (data: Partial<Omit<AboutContentSQL, 'id' | 'created_at'>>): Promise<AboutContentSQL> => {
    await delay(SIMULATED_DELAY);
    loadDb();
    const currentContent = mockDb.about_content[0] || { ...initialMockDbData.about_content[0], id: 'ac_main' };
    mockDb.about_content[0] = { ...currentContent, ...data, id: currentContent.id, created_at: currentContent.created_at || new Date().toISOString() };
    persistDb();
    return JSON.parse(JSON.stringify(mockDb.about_content[0]));
};


// --- Services ---
export const getServices = async (): Promise<ServiceSQL[]> => {
    await delay(SIMULATED_DELAY);
    loadDb();
    return JSON.parse(JSON.stringify(mockDb.services));
};

export const createService = async (data: Omit<ServiceSQL, 'id' | 'created_at'>): Promise<ServiceSQL> => {
    await delay(SIMULATED_DELAY);
    loadDb();
    const newService: ServiceSQL = { ...data, id: generateId(), created_at: new Date().toISOString() };
    mockDb.services.unshift(newService);
    persistDb();
    return JSON.parse(JSON.stringify(newService));
};

export const updateService = async (id: string, data: Partial<Omit<ServiceSQL, 'id' | 'created_at'>>): Promise<ServiceSQL | null> => {
    await delay(SIMULATED_DELAY);
    loadDb();
    const index = mockDb.services.findIndex(s => s.id === id);
    if (index === -1) return null;
    mockDb.services[index] = { ...mockDb.services[index], ...data };
    persistDb();
    return JSON.parse(JSON.stringify(mockDb.services[index]));
};

export const deleteService = async (id: string): Promise<boolean> => {
    await delay(SIMULATED_DELAY);
    loadDb();
    const initialLength = mockDb.services.length;
    mockDb.services = mockDb.services.filter(s => s.id !== id);
    const success = mockDb.services.length < initialLength;
    if (success) persistDb();
    return success;
};


// --- Facilities ---
export const getFacilities = async (): Promise<FacilitySQL[]> => {
    await delay(SIMULATED_DELAY);
    loadDb();
    return JSON.parse(JSON.stringify(mockDb.facilities));
};

export const createFacility = async (data: Omit<FacilitySQL, 'id' | 'created_at'>): Promise<FacilitySQL> => {
    await delay(SIMULATED_DELAY);
    loadDb();
    const newFacility: FacilitySQL = { ...data, id: generateId(), created_at: new Date().toISOString() };
    mockDb.facilities.unshift(newFacility);
    persistDb();
    return JSON.parse(JSON.stringify(newFacility));
};

export const updateFacility = async (id: string, data: Partial<Omit<FacilitySQL, 'id' | 'created_at'>>): Promise<FacilitySQL | null> => {
    await delay(SIMULATED_DELAY);
    loadDb();
    const index = mockDb.facilities.findIndex(f => f.id === id);
    if (index === -1) return null;
    mockDb.facilities[index] = { ...mockDb.facilities[index], ...data };
    persistDb();
    return JSON.parse(JSON.stringify(mockDb.facilities[index]));
};

export const deleteFacility = async (id: string): Promise<boolean> => {
    await delay(SIMULATED_DELAY);
    loadDb();
    const initialLength = mockDb.facilities.length;
    mockDb.facilities = mockDb.facilities.filter(f => f.id !== id);
    const success = mockDb.facilities.length < initialLength;
    if (success) persistDb();
    return success;
};


// --- Departments ---
export const getDepartments = async (): Promise<DepartmentSQL[]> => {
    await delay(SIMULATED_DELAY);
    loadDb();
    return JSON.parse(JSON.stringify(mockDb.departments));
};

export const createDepartment = async (data: Omit<DepartmentSQL, 'id' | 'created_at'>): Promise<DepartmentSQL> => {
    await delay(SIMULATED_DELAY);
    loadDb();
    const newDepartment: DepartmentSQL = { ...data, id: generateId(), created_at: new Date().toISOString() };
    mockDb.departments.unshift(newDepartment);
    persistDb();
    return JSON.parse(JSON.stringify(newDepartment));
};

export const updateDepartment = async (id: string, data: Partial<Omit<DepartmentSQL, 'id' | 'created_at'>>): Promise<DepartmentSQL | null> => {
    await delay(SIMULATED_DELAY);
    loadDb();
    const index = mockDb.departments.findIndex(d => d.id === id);
    if (index === -1) return null;
    mockDb.departments[index] = { ...mockDb.departments[index], ...data };
    persistDb();
    return JSON.parse(JSON.stringify(mockDb.departments[index]));
};

export const deleteDepartment = async (id: string): Promise<boolean> => {
    await delay(SIMULATED_DELAY);
    loadDb();
    const initialLength = mockDb.departments.length;
    mockDb.departments = mockDb.departments.filter(d => d.id !== id);
    const success = mockDb.departments.length < initialLength;
    if (success) persistDb();
    return success;
};


// --- Gallery Items ---
export const getGalleryItems = async (): Promise<GalleryItemSQL[]> => {
    await delay(SIMULATED_DELAY);
    loadDb();
    return JSON.parse(JSON.stringify(mockDb.gallery_items.sort((a, b) => (a.position || 0) - (b.position || 0))));
};

export const createGalleryItem = async (data: Omit<GalleryItemSQL, 'id' | 'created_at'>): Promise<GalleryItemSQL> => {
    await delay(SIMULATED_DELAY);
    loadDb();
    const newItem: GalleryItemSQL = { ...data, id: generateId(), created_at: new Date().toISOString() };
    mockDb.gallery_items.unshift(newItem);
    persistDb();
    return JSON.parse(JSON.stringify(newItem));
};

export const updateGalleryItem = async (id: string, data: Partial<Omit<GalleryItemSQL, 'id' | 'created_at'>>): Promise<GalleryItemSQL | null> => {
    await delay(SIMULATED_DELAY);
    loadDb();
    const index = mockDb.gallery_items.findIndex(g => g.id === id);
    if (index === -1) return null;
    mockDb.gallery_items[index] = { ...mockDb.gallery_items[index], ...data };
    persistDb();
    return JSON.parse(JSON.stringify(mockDb.gallery_items[index]));
};

export const deleteGalleryItem = async (id: string): Promise<boolean> => {
    await delay(SIMULATED_DELAY);
    loadDb();
    const initialLength = mockDb.gallery_items.length;
    mockDb.gallery_items = mockDb.gallery_items.filter(g => g.id !== id);
    const success = mockDb.gallery_items.length < initialLength;
    if (success) persistDb();
    return success;
};


// --- News Events ---
export const getNewsEvents = async (): Promise<NewsEventSQL[]> => {
    await delay(SIMULATED_DELAY);
    loadDb();
    // Ensure date is a string when returned, sort by date descending
    return JSON.parse(JSON.stringify(
        mockDb.news_events.map(event => ({
            ...event,
            date: typeof event.date === 'string' ? event.date : new Date(event.date).toISOString().split('T')[0]
        })).sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())
    ));
};

export const getNewsEventById = async (id: string): Promise<NewsEventSQL | undefined> => {
    await delay(SIMULATED_DELAY);
    loadDb();
    const item = mockDb.news_events.find(n => n.id === id || n.link === `/news/${id}`);
    if (item) {
        return JSON.parse(JSON.stringify({
            ...item,
            date: typeof item.date === 'string' ? item.date : new Date(item.date).toISOString().split('T')[0]
        }));
    }
    return undefined;
};

export const createNewsEvent = async (data: Omit<NewsEventSQL, 'id' | 'created_at'>): Promise<NewsEventSQL> => {
    await delay(SIMULATED_DELAY);
    loadDb();
    // Ensure date is string 'YYYY-MM-DD'
    const dateString = typeof data.date === 'string' ? data.date : new Date(data.date).toISOString().split('T')[0];
    const newEvent: NewsEventSQL = { ...data, date: dateString, id: generateId(), created_at: new Date().toISOString() };
    mockDb.news_events.push(newEvent);
    mockDb.news_events.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
    persistDb();
    return JSON.parse(JSON.stringify(newEvent));
};

export const updateNewsEvent = async (id: string, data: Partial<Omit<NewsEventSQL, 'id' | 'created_at'>>): Promise<NewsEventSQL | null> => {
    await delay(SIMULATED_DELAY);
    loadDb();
    const index = mockDb.news_events.findIndex(n => n.id === id);
    if (index === -1) return null;

    const updatedData = { ...data };
    if (updatedData.date) {
        updatedData.date = typeof updatedData.date === 'string' ? updatedData.date : new Date(updatedData.date).toISOString().split('T')[0];
    }

    mockDb.news_events[index] = { ...mockDb.news_events[index], ...updatedData };
    mockDb.news_events.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
    persistDb();
    return JSON.parse(JSON.stringify(mockDb.news_events[index]));
};

export const deleteNewsEvent = async (id: string): Promise<boolean> => {
    await delay(SIMULATED_DELAY);
    loadDb();
    const initialLength = mockDb.news_events.length;
    mockDb.news_events = mockDb.news_events.filter(n => n.id !== id);
    const success = mockDb.news_events.length < initialLength;
    if (success) persistDb();
    return success;
};


// --- Contact Info (Single Row Table) ---
export const getContactInfo = async (): Promise<ContactInfoSQL> => {
    await delay(SIMULATED_DELAY);
    loadDb();
    return JSON.parse(JSON.stringify(mockDb.contact_info[0] || initialMockDbData.contact_info[0]));
};

export const updateContactInfo = async (data: Partial<Omit<ContactInfoSQL, 'id' | 'created_at'>>): Promise<ContactInfoSQL> => {
    await delay(SIMULATED_DELAY);
    loadDb();
    const currentInfo = mockDb.contact_info[0] || { ...initialMockDbData.contact_info[0], id: 'ci_main'};
    mockDb.contact_info[0] = { ...currentInfo, ...data, id: currentInfo.id, created_at: currentInfo.created_at || new Date().toISOString() };
    persistDb();
    return JSON.parse(JSON.stringify(mockDb.contact_info[0]));
};

// --- Authentication (Mock) ---
const MOCK_ADMIN_USERNAME = 'admin';
const MOCK_ADMIN_PASSWORD = 'password123';

export const verifyAdminCredentials = async (username?: string, password?: string): Promise<boolean> => {
    await delay(SIMULATED_DELAY * 2);
    return username === MOCK_ADMIN_USERNAME && password === MOCK_ADMIN_PASSWORD;
};

// Types that were used by frontend components, map SQL types to them if different.
// For now, we'll assume direct mapping is mostly fine, but frontend components might need adjustments if they expect different field names.
export type {
    SiteSettingsSQL as SiteSettings,
    HeroSlideSQL as HeroSlide,
    AboutContentSQL as AboutContent,
    ServiceSQL as Service,
    FacilitySQL as Facility,
    DepartmentSQL as Department,
    GalleryItemSQL as GalleryItem,
    NewsEventSQL as NewsEvent,
    ContactInfoSQL as ContactInfo
};
