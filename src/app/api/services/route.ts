
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { query } from '@/lib/mysql';
import type { ServiceSQL } from '@/lib/schema-types';

// GET all services
export async function GET() {
  try {
    const services = await query('SELECT * FROM services ORDER BY created_at DESC');
    return NextResponse.json(services);
  } catch (error: any) {
    console.error('API Error GET /api/services:', error);
    return NextResponse.json({ message: 'Failed to fetch services', error: error.message }, { status: 500 });
  }
}

// POST a new service
export async function POST(request: NextRequest) {
  try {
    const data = await request.json() as Omit<ServiceSQL, 'id' | 'created_at'>;
    
    if (!data.name || !data.description || !data.detailedDescription || !data.iconName) {
        return NextResponse.json({ message: 'Missing required fields' }, { status: 400 });
    }

    const sql = 'INSERT INTO services (name, description, detailedDescription, iconName) VALUES (?, ?, ?, ?)';
    const result: any = await query(sql, [data.name, data.description, data.detailedDescription, data.iconName]);
    
    const newServiceId = result.insertId; // This might vary based on your DB/driver (e.g. MariaDB)
                                         // For UUIDs generated by DB, you might need to SELECT the row back if insertId isn't the UUID
                                         // For now, let's assume it's okay, or better, fetch it:

    const newService = await query('SELECT * FROM services WHERE id = (SELECT LAST_INSERT_ID() AS id)'); // For auto-increment ID
    // If using UUIDs generated by the DB:
    // This part is tricky without knowing the exact DB behavior for returning the new UUID.
    // Often, you'd pass the UUID from the client or generate it in the API route *before* insert if the DB doesn't return it.
    // For this schema with DEFAULT gen_random_uuid(), we assume we can't get insertId directly as UUID.
    // A robust way is to fetch the *latest* inserted record, but that's not perfectly safe with concurrent requests.
    // For simplicity, if your id is auto-generated by DB, and LAST_INSERT_ID() works for non-UUID PKs, it's fine.
    // Given our schema uses UUID PRIMARY KEY DEFAULT gen_random_uuid(), we can't rely on LAST_INSERT_ID() for the UUID.
    // The best approach is to generate UUID in the API if not returned by DB on insert, or to query back by other unique fields if possible.
    // However, for now, we'll assume a simple select back by what was inserted if there's a unique constraint on name for example.
    // For now, we will return the input data with a placeholder ID as the DB will assign the true UUID.
    // The client should then re-fetch or the API should return the full new object.
    // Let's try to fetch it by name and other data as a temporary measure.

    // A better approach for UUIDs: SELECT * FROM services WHERE name = ? AND description = ? ORDER BY created_at DESC LIMIT 1
    // This is still not ideal. Best is if the INSERT statement could return the ID.
    // For now, we'll just return the data we sent, assuming the client will re-fetch or handle it.
    // A more robust method for INSERT with server-generated UUID:
    // 1. Generate UUID in the API route: `const newId = crypto.randomUUID();`
    // 2. Insert with this ID: `INSERT INTO services (id, name, ...) VALUES (newId, data.name, ...)`
    // 3. Then `SELECT * FROM services WHERE id = newId;`

    // For this pass, let's just return the created data based on what was sent.
    // The client side often re-fetches the list after creation anyway.
    // A proper solution for returning the created entity with its DB-generated ID:
    const fetchBackSql = 'SELECT * FROM services WHERE name = ? AND description = ? AND detailedDescription = ? AND iconName = ? ORDER BY created_at DESC LIMIT 1';
    const newServices = await query(fetchBackSql, [data.name, data.description, data.detailedDescription, data.iconName]) as ServiceSQL[];

    if (newServices.length > 0) {
        return NextResponse.json(newServices[0], { status: 201 });
    } else {
        // This fallback is not ideal but covers cases where the immediate select back fails.
        return NextResponse.json({ message: 'Service created, but could not fetch it back immediately.' }, { status: 201 });
    }

  } catch (error: any) {
    console.error('API Error POST /api/services:', error);
    return NextResponse.json({ message: 'Failed to create service', error: error.message }, { status: 500 });
  }
}
